  The ocl_xrpd1D_fullsplit class creates an object for 1D Azimuthal regroupping with full pixel-split
  on an OpenCL device.
  
  The algorithms are meant to be part of and compatible with PyFAI. As such the conventions of PyFAI for 
  masks, dummy-values, ranges, and the way the pixel-split is performed apply here aswell.
  
  All the arrays (2th, d2th, Image, Integrated image, Weights, Solidangle, Mask) are numpy 1d arrays (flattened).
  Also all except for mask are of type numpy.float32. Mask is numpy.int32.
 
  The library is optimised to be called interactively. After a required configuration stage (which can be
  changed at will at any point), other integration options can be enabled/disabled/updated indefinately 
  without the need of creating a new object. This is explained better later, after the available methods are 
  reviewed.
  
  At least one OpenCL library/driver must be present. For GPUs an OpenCL library is provided along with 
  the driver of the GPU. For CPUs an OpenCL library must be acquired either by installing the Inter and/or 
  AMD SDKs (OpenCL SDK and APP SDK respectively). For other types of OpenCL devices, such as accelerators 
  (e.g. SteamCell DSP or IBM CELL B/E) appropriate SDK should be available at the manufacturer's website.
  
  In order to check which OpenCL platforms (Nvidia,AMD,Intel etc...) are installed and which devices are 
  OpenCL capable you may invoke the show_devices() or print_devices() method.
  
-------------------------------------------------------------------------------------------------------------
  List of methods:
  
  
   Construction:
 
    ocl_xrpd1D_fullsplit()           - Default construction of the object. Uses stdout as stream

    ocl_xrpd1D_fullsplit("filename") - Same as default construction, but diverts output to file 

  
  
   Utilities: 

    show_devices()                    - Returns the list of OpenCL platforms and devices present 

    get_exec_time()                   - Returns the total kernel execution time in milliseconds

    get_memCpy_time()                 - Returns the total buffer copy time in milliseconds

    get_exec_count()                  - Returns the number execute() has been called

    reset_time()                      - Resets execution and memory copy times as well as the execution counter

    clean(PyINT preserve_context = 0) - Bring the object to a clean state. Typically used internally, but
                                        if one encounters any problems may call to try to avoid further 
                                        problems.

    show_devices()                    - Prints a list of the discovered OpenCL platforms and devices. The list
                                        is printed to stream.

    print_devices()                   - Same as show_devices() but explicitly only prints the list to stdout
                                        (screen).
  
  
   Computation: 

    init(PyBOOL ReqFP64 = True) - 
    Request the default type of device for the computation. OpenCL default device type depends on the OpenCL 
    library. ReqFP64 instructs the library to ignore non double-precision capable devices which is optional 
    and is True by default.
  
    init(PyString DeviceType, PyBOOL...) -
    Request a type of device "DeviceType". The string can be: "gpu","cpu","def","all","acc". 

    init(PyString DeviceType, PyINT PlatformID, PyINT DeviceID, PyBOOL...) -
    Request a type of device "DeviceType" that resided in the given platformID and has the specified deviceID. 
    To find the deviceIDs and platformIDs one may invoke show_devices().
  
    getConfiguration(PyINT ImageStride, PyINT ImageSize, PyINT NumberOfBins, PyBOOL UseFP64 = True) - 
    Creates a description fo the configuration fo be performed. UseFP64 tell the library to create a
    configuration for double precision. By default the value is True.
  
    configure() - Configures the OpenCL device and compiles the OpenCL kernels.
  
    loadTth(NDARRAY Tth, NDARRAY dTth, PyFloat tth_min, PyFloat tth_max ) -
    Loads flattened float32 numpy arrays with the 2th and d2th values, the min and the max all in float32 .
  
    execute(NDARRAY Image, NDARRAY Integrated, NDARRAY Weights) - 
    Performs the integration of Image based on the configuration that exists
  


   Computation Options - Enabling/Disabling a Mask:
 
    setMask(NDARRY Mask) - Enable the use of mask using the provided mask or update the existing mask

    unsetMask()          - Disable the use of mask
  

  
   Computation Options - Enabling/Disabling 2th range: 

    setRange(PyFloat lowerBound, PyFloat upperBound) - Enable the use of user-defined integration range
                                                       or update the existing range

    unsetRange() - Disable the use of user-defined range (Integrate on full tth_min |<->| tth_max range)
  
  

   Computation Options - Enabling/Disabling a dummy value:   

    setDummyVal(PyFloat dummyVal) - Enable/Update a dummy value

    unsetDummyVal()               - Disable the use of a dummy value

  
  
   Computation Options - Enabling/Disabling solid angle correction: 

    setSolidAngle(NDARRAY solidangle) - Enable solidangle correction using the provided array
                                        Update the existing array

    unsetSolidAngle()                 - Disable solidangle correction

-------------------------------------------------------------------------------------------------------------
How to use the library:

As seen above, the methods available are grouped in 4 main categories. Construction, Utilities, Computation 
and Computation Options. 
Upon construction of an xprd1d object the only usable ulitily is "show_devices()" which
can be used to note the IDs of a specific OpenCL device if needed.

1) Call init() in order to select an OpenCL device to use. init() can be recalled at any given point to change
   device. If clean(0) is called, unlike clean(1), init() will have to be called again.

2) Call getConfiguration() so that the library can record the characteristics of the image and the 
   integration parameters. In order to change input image size of integration parameters getConfiguration()
   must be called again.

3) Call configure(). Configure allocates the required OpenCL resources and compiles the OpenCL kernels.
   if init() or clean(1/0) is called configure() must be called again. If the parameters for the image and 
   integrations have been changed by getConfiguration(), configure() must be called for them to take effect.

4) Call loadTth(). The library requires a 2th and d2th array before executing. These arrays are kept in memory
   and used no matter how many integrations are performed. In order to update the arraya, call loadTth() again
   at any point.

5) Call execute. Performs the integration. Can be called multiple times. The prerequisites to call execute are:
   - an OpenCL device must have been selected via init()
   - a configuration given via getConfigure() at least once
   - after each new call to getConfigure(), configure() has been called at least once
   - loadTth has been called at least once.

a) set/unset functions are optional and can be called at any point as long as the prerequisites for execute() 
   are ment.
   Any set/unset method will have a direct impact on the actions performed by execute().

b) Profiling information can be acquired at any time by calling the get_exec_time, get_memCpy_time and 
   get_exec_count.
   get_exec_time and get_exec_count results are in milliseconds and are only influenced by execute() calls.
   get_memCpy_time results are influenced by all methods that perform memory copy operations:
   loadTth, set methods, execute()
   get_exec_time + get_memCpy_time is the total execution time in milliseconds for all the lifetime of the 
   object, or since the last call to reset_time().

-------------------------------------------------------------------------------------------------------------
Examples:

Simple Python

import oclAzimuthal1d
hdl = oclAzimuthal1d.ocl_xrpd1d_fullsplit()
hdl.init("gpu")
hdl.getConfiguration(1024,1024*2048,1000)
hdl.configure()
hdl.loadTth(tth,dtth,(tth-dtth).min(),(tth+dtth).max())
hdl.execute(image,integrated,weights)
del hdl

Example with options:

import oclAzimuthal1d
hdl = oclAzimuthal1d.ocl_xrpd1d_fullsplit("output.txt")  
hdl.show_devices() #we mark gpu device 1 on platform 2
hdl.init("gpu",2,1,False)
hdl.getConfiguration(1023,1023*2000,1000,False)
hdl.configure()
hdl.loadTth(tth,dtth,(tth-dtth).min(),(tth+dtth).max())
for i in range(100):
	hdl.execute(images[:,i],integrations[:,i],weights[:,i])
print hdl.get_exec_time()/hdl.get_exec_count()

#We upload a mask
hdl.setMask(maskArray)
for i in range(100):
	hdl.execute(images[:,i],integrations[:,i],weights[:,i])

#we set a dummyvalue and the next executes will use dummy AND mask
hdl.setDummyVal(80)
for i in range(100):
	hdl.execute(images[:,i],integrations[:,i],weights[:,i])

#We unset dummy and set solidangle. The executions will use mask AND solidangle
hdl.unsetDummyVal()
hdl.setSolidAngle(solidangleArray)
hdl.execute(image,integrated,weight)
hdl.clean(1)

#We cleanup preserving the opencl device, we can run configure
hdl.configure()
...
hdl.clean(0)

#"Deep" clean up we need to start from init()
hdl.init()
....
hdl.configure()

#we change configuration and call configure() for the changes to take effect
hdl.getConfiguration()
hdl.configure()

#change device and start over
hdl.init()
hdl.getconfiguration()
....
del hdl

For more information on the API please check the Reference API Documentation

